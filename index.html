<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Flight Fuel Utils</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- Icône & PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#101018">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="icon-192.png">

  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background-color: #101018;
      color: #f7f7fb;
    }
    .app {
      max-width: 520px;
      margin: 0 auto;
      padding: 24px 18px 44px;
    }
    h1 {
      font-size: 24px;
      margin: 0 0 18px;
      text-align: center;
      font-weight: 700;
    }
    .group-title {
      margin-top: 20px;
      margin-bottom: 8px;
      font-size: 16px;
      opacity: 0.9;
    }
    label {
      font-size: 15px;
      opacity: 0.95;
    }
    .row {
      display: flex;
      flex-direction: column;
      margin-bottom: 14px;
    }

    input {
      margin-top: 6px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #3a3a48;
      background-color: #171725;
      color: #ffffff;
      font-size: 18px;
      font-weight: 600;
      transition: border-color 0.15s ease, background-color 0.15s ease;
    }
    input::placeholder {
      color: #7f7f9a;
    }
    input:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(10,132,255,0.35);
    }

    /* bleu = entrées K & Taxi à figer après calcul */
    .state-edit {
      border-color: #0a84ff;
    }
    /* jaune = variables d'ajustement (ZFW, RFL, Block) */
    .state-adjust {
      border-color: #f5c445;
      background-color: #252020;
    }
    /* vert = K & Taxi verrouillés après calcul */
    .state-locked {
      border-color: #2ecc71;
      background-color: #16241b;
    }
    /* vert clair = valeurs de résultat */
    .state-result-value {
      color: #7fffb0;
    }

    /* champs impactés par une limitation dominante */
    .state-limited-tow {
      border-color: #ff9f1a !important;
      background-color: #2a1e08 !important;
    }
    .state-limited-law {
      border-color: #4ec3ff !important;
      background-color: #082234 !important;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .buttons {
      display: flex;
      gap: 12px;
      margin-top: 14px;
      margin-bottom: 20px;
    }
    button {
      flex: 1;
      padding: 12px 0;
      border-radius: 12px;
      border: none;
      font-size: 17px;
      font-weight: 700;
      cursor: pointer;
    }
    #btnCalc {
      background-color: #0a84ff;
      color: #ffffff;
    }
    #btnReset {
      background-color: #2e2e3c;
      color: #ffffff;
    }

    .results {
      margin-top: 10px;
      padding: 14px 14px 12px;
      border-radius: 14px;
      background-color: #181828;
      border: 1px solid #3b3b4f;
    }

    .result-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 18px;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .result-label {
      opacity: 0.9;
    }
    .result-value {
      font-weight: 700;
      color: #ffffff;
    }

    /* Champs de limitation TOW / LAW */
    .limit-input {
      max-width: 140px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 2px solid #ff9f1a;
      background-color: #2a1e08;
      color: #ffffff;
      font-size: 15px;
      font-weight: 700;
    }
    .limit-input-law {
      border-color: #4ec3ff;
      background-color: #082234;
    }
    .limit-input::placeholder {
      color: #ffcf80;
      font-weight: 500;
    }
    .limit-input-law::placeholder {
      color: #a0e3ff;
      font-weight: 500;
    }
    .limit-input-muted {
      opacity: 0.6;
      border-style: dashed;
    }

    .limit-info {
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.8;
      line-height: 1.3;
    }

    .limit-info span {
      font-weight: 600;
    }

    .footer {
      margin-top: 22px;
      font-size: 13px;
      text-align: center;
      opacity: 0.7;
      line-height: 1.4;
    }

    @media (max-width: 480px) {
      .app {
        padding: 20px 14px 32px;
      }
      .grid-2 {
        grid-template-columns: 1fr;
      }
      .result-row {
        font-size: 17px;
      }
      input {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <h1>Flight Fuel Utils</h1>

  <div class="group-title">Entrées (tonnes)</div>
  <div class="row">
    <label for="zfw">ZFW (T)</label>
    <input id="zfw" class="state-adjust" type="text" inputmode="decimal" placeholder="ex. 180.5">
  </div>

  <div class="row">
    <label for="k">K (coef &gt; 1, 3 décimales)</label>
    <input id="k" class="state-edit" type="text" inputmode="decimal" placeholder="ex. 1.037">
  </div>

  <div class="grid-2">
    <div class="row">
      <label for="taxi">Taxi (T)</label>
      <input id="taxi" class="state-edit" type="text" inputmode="decimal" placeholder="ex. 0.4">
    </div>
    <div class="row">
      <label for="rfl">Remaining Fuel at Landing (T)</label>
      <input id="rfl" class="state-adjust" type="text" inputmode="decimal" placeholder="ex. 7.0">
    </div>
  </div>

  <div class="row">
    <label for="block">Block Fuel (T)</label>
    <input id="block" class="state-adjust" type="text" inputmode="decimal" placeholder="ex. 25.3">
  </div>

  <div class="buttons">
    <button id="btnCalc">Calcul</button>
    <button id="btnReset">Reset</button>
  </div>

  <div class="results" id="resultsBox">
    <!-- TOW + limitation -->
    <div class="result-row">
      <div class="result-label">TOW (T)</div>
      <div class="result-value state-result-value" id="mtow">–</div>
      <input id="towLimit" class="limit-input" type="text" inputmode="decimal" placeholder="Lim TOW (T)">
    </div>

    <!-- Trip -->
    <div class="result-row">
      <div class="result-label">Trip Fuel (T)</div>
      <div class="result-value state-result-value" id="trip">–</div>
    </div>

    <!-- LAW + limitation -->
    <div class="result-row">
      <div class="result-label">LAW (T)</div>
      <div class="result-value state-result-value" id="mlw">–</div>
      <input id="lawLimit" class="limit-input limit-input-law" type="text" inputmode="decimal" placeholder="Lim LAW (T)">
    </div>

    <div class="limit-info" id="limitInfo">
      <!-- Texte dynamique : ZFW Max / Block Fuel Max / limitation dominante -->
    </div>
  </div>

  <div class="footer">
    ZFW + RFL = LAW · LAW × K = TOW · Trip = TOW − LAW · Block = Taxi + Trip + RFL
  </div>
</div>

<script>
let hasCalculated = false;

function parseValOrNaN(id) {
  const raw = document.getElementById(id).value.trim().replace(',', '.');
  return raw === '' ? NaN : parseFloat(raw);
}
function fmt1(x) {
  if (isNaN(x)) return '–';
  return x.toFixed(1);
}
// arrondi au dixième supérieur, sauf si déjà sur un dixième exact
function ceil1strict(x) {
  if (isNaN(x)) return NaN;
  const val   = Math.round(x * 1000) / 1000;
  const tenth = Math.round(val * 10) / 10;
  if (Math.abs(val - tenth) < 1e-9) {
    return tenth;
  }
  return Math.ceil(val * 10) / 10;
}
// normalise l'affichage d'un input avec un point et n décimales
function normalizeInputValue(id, decimals = 1) {
  const el  = document.getElementById(id);
  const num = parseValOrNaN(id);
  if (isNaN(num)) return;
  el.value = num.toFixed(decimals);
}

function setLocked(id, locked) {
  const el = document.getElementById(id);
  el.readOnly = locked;
  el.classList.remove('state-edit', 'state-locked');
  el.classList.add(locked ? 'state-locked' : 'state-edit');
}

const zfwEl     = document.getElementById('zfw');
const kEl       = document.getElementById('k');
const taxiEl    = document.getElementById('taxi');
const rflEl     = document.getElementById('rfl');
const blockEl   = document.getElementById('block');
const mtowEl    = document.getElementById('mtow');
const mlwEl     = document.getElementById('mlw');
const tripEl    = document.getElementById('trip');
const towLimEl  = document.getElementById('towLimit');
const lawLimEl  = document.getElementById('lawLimit');
const limitInfoEl = document.getElementById('limitInfo');

function clearResults() {
  mtowEl.textContent = '–';
  mlwEl.textContent  = '–';
  tripEl.textContent = '–';
}

function resetLimitStyling() {
  zfwEl.classList.remove('state-limited-tow', 'state-limited-law');
  blockEl.classList.remove('state-limited-tow', 'state-limited-law');
  rflEl.classList.remove('state-limited-law');
  towLimEl.classList.remove('limit-input-muted');
  lawLimEl.classList.remove('limit-input-muted');
}

function clearLimitsAndDerived() {
  towLimEl.value = '';
  lawLimEl.value = '';
  zfwEl.value   = '';
  blockEl.value = '';
  resetLimitStyling();
  clearResults();
  limitInfoEl.textContent = '';
  hasCalculated = false;
}

function handleLimitInputClear(el) {
  const val = el.value.trim();
  if (val === '') {
    clearLimitsAndDerived();
  }
}

// RFL / Block : si l’un change, on efface l’autre ET les limites
['rfl','block'].forEach(id => {
  const el = document.getElementById(id);
  el.addEventListener('input', () => {
    const otherId = id === 'rfl' ? 'block' : 'rfl';
    const otherEl = document.getElementById(otherId);
    otherEl.value = '';
    towLimEl.value = '';
    lawLimEl.value = '';
    resetLimitStyling();
    limitInfoEl.textContent = '';
  });
});

// ZFW : après un calcul, toute modification invalide RFL, Block, résultats et limites
zfwEl.addEventListener('input', () => {
  if (!hasCalculated) return;
  rflEl.value   = '';
  blockEl.value = '';
  clearLimitsAndDerived();
});

// K / Taxi / RFL / Block : si on change après une limitation, on efface le style limites
[kEl, taxiEl, rflEl, blockEl].forEach(el => {
  el.addEventListener('input', () => {
    resetLimitStyling();
    limitInfoEl.textContent = '';
  });
});

document.getElementById('btnCalc').addEventListener('click', function () {
  let zfw   = parseValOrNaN('zfw');
  let k     = parseValOrNaN('k');
  let taxi  = parseValOrNaN('taxi');
  let rfl   = parseValOrNaN('rfl');
  let block = parseValOrNaN('block');

  if (isNaN(zfw) || isNaN(k) || isNaN(taxi)) {
    alert('Renseigne ZFW, K et Taxi, puis soit RFL soit Block.');
    return;
  }

  hasCalculated = true;

  // normaliser l'affichage des entrées (point décimal partout)
  normalizeInputValue('zfw');
  normalizeInputValue('k', 3);
  normalizeInputValue('taxi');
  if (!isNaN(rfl))   normalizeInputValue('rfl');
  if (!isNaN(block)) normalizeInputValue('block');

  // relire après normalisation
  zfw   = parseValOrNaN('zfw');
  k     = parseValOrNaN('k');
  taxi  = parseValOrNaN('taxi');
  rfl   = parseValOrNaN('rfl');
  block = parseValOrNaN('block');

  setLocked('k', true);
  setLocked('taxi', true);

  // Cas 1 : RFL donné
  if (!isNaN(rfl)) {
    const law  = zfw + rfl;
    const tow  = law * k;
    const trip = tow - law;

    if (isNaN(block)) {
      block = taxi + trip + rfl;
      block = ceil1strict(block);
      blockEl.value = block.toFixed(1);
    }

    rflEl.value = rfl.toFixed(1);
    mlwEl.textContent  = fmt1(law);
    mtowEl.textContent = fmt1(ceil1strict(tow));
    tripEl.textContent = fmt1(trip);
    return;
  }

  // Cas 2 : Block donné, RFL vide -> on résout RFL
  if (isNaN(rfl) && !isNaN(block)) {
    const rflSolved = (block - taxi - zfw * (k - 1)) / k;
    rfl = rflSolved;
    rflEl.value = rfl.toFixed(1);

    const law  = zfw + rfl;
    const tow  = law * k;
    const trip = tow - law;

    mlwEl.textContent  = fmt1(law);
    mtowEl.textContent = fmt1(ceil1strict(tow));
    tripEl.textContent = fmt1(trip);
    return;
  }

  alert('Renseigne soit RFL, soit Block (une seule des deux).');
});

// --- Fonctions helpers limites ---

function computeTowFromTowLimit() {
  const towLim = parseValOrNaN('towLimit');
  if (isNaN(towLim)) return NaN;
  return towLim;
}

function computeTowFromLawLimit() {
  const lawLim = parseValOrNaN('lawLimit');
  const k      = parseValOrNaN('k');
  if (isNaN(lawLim) || isNaN(k) || k <= 0) return NaN;
  return lawLim * k;
}

// Applique la logique en tenant compte des deux limites si présentes
function applyLimits() {
  resetLimitStyling();
  limitInfoEl.textContent = '';

  const zfw   = parseValOrNaN('zfw');
  const k     = parseValOrNaN('k');
  const taxi  = parseValOrNaN('taxi');
  let   rfl   = parseValOrNaN('rfl');

  if (isNaN(zfw) || isNaN(k) || isNaN(taxi) || k <= 0 || isNaN(rfl)) {
    return;
  }

  const towFromTow = computeTowFromTowLimit();
  const towFromLaw = computeTowFromLawLimit();

  const hasTowLim = !isNaN(towFromTow);
  const hasLawLim = !isNaN(towFromLaw);

  if (!hasTowLim && !hasLawLim) {
    return;
  }

  if (hasTowLim && !hasLawLim) {
    applyTowOnly(towFromTow, zfw, k, taxi, rfl);
    return;
  }

  if (!hasTowLim && hasLawLim) {
    applyLawOnly(towFromLaw, zfw, k, taxi, rfl);
    return;
  }

  const towMaxTow = towFromTow;
  const towMaxLaw = towFromLaw;

  if (towMaxLaw <= towMaxTow) {
    applyLawOnly(towMaxLaw, zfw, k, taxi, rfl, true);
    towLimEl.classList.add('limit-input-muted');
  } else {
    applyTowOnly(towMaxTow, zfw, k, taxi, rfl, true);
    lawLimEl.classList.add('limit-input-muted');
  }
}

// --- Application logique TOW seule/dominante ---
function applyTowOnly(towMax, zfw, k, taxi, rfl, towDominant = true) {
  const lawMax = towMax / k;
  let zfwMax = lawMax - rfl;
  if (zfwMax < 0) zfwMax = 0;

  let blockNew = towMax - zfwMax + taxi;
  if (blockNew < 0) blockNew = 0;
  blockNew = ceil1strict(blockNew);

  zfwEl.value   = zfwMax.toFixed(1);
  blockEl.value = blockNew.toFixed(1);

  if (towDominant) {
    zfwEl.classList.add('state-limited-tow');
    blockEl.classList.add('state-limited-tow');
    limitInfoEl.innerHTML = '<span>ZFW Max</span> appliqué (limitation TOW).';
  }

  document.getElementById('btnCalc').click();
}

// --- Application logique LAW seule/dominante ---
function applyLawOnly(towMax, zfw, k, taxi, rfl, lawDominant = true) {
  const lawLimit = towMax / k;

  let zfwNew   = zfw;
  let rflNew   = rfl;
  let blockNew;

  const lawCurrent = zfw + rfl;

  if (lawLimit < lawCurrent) {
    let zfwMax = lawLimit - rfl;
    if (zfwMax < 0) zfwMax = 0;
    zfwNew = zfwMax;

    blockNew = towMax - zfwMax + taxi;
    if (blockNew < 0) blockNew = 0;
  } else {
    rflNew = lawLimit - zfw;
    if (rflNew < 0) rflNew = 0;

    blockNew = towMax - zfw + taxi;
    if (blockNew < 0) blockNew = 0;
  }

  blockNew = ceil1strict(blockNew);

  zfwEl.value   = zfwNew.toFixed(1);
  rflEl.value   = rflNew.toFixed(1);
  blockEl.value = blockNew.toFixed(1);

  if (lawDominant) {
    zfwEl.classList.add('state-limited-law');
    rflEl.classList.add('state-limited-law');
    blockEl.classList.add('state-limited-law');
    limitInfoEl.innerHTML = '<span>Block Fuel Max</span> appliqué (limitation LAW).';
  }

  document.getElementById('btnCalc').click();
}

// Handlers limites

function onTowLimitChange() {
  const val = towLimEl.value.trim();
  if (val === '') {
    handleLimitInputClear(towLimEl);
    return;
  }
  // normaliser aussi la limite TOW
  normalizeInputValue('towLimit');
  applyLimits();
}

function onLawLimitChange() {
  const val = lawLimEl.value.trim();
  if (val === '') {
    handleLimitInputClear(lawLimEl);
    return;
  }
  // normaliser aussi la limite LAW
  normalizeInputValue('lawLimit');
  applyLimits();
}

towLimEl.addEventListener('blur', onTowLimitChange);
towLimEl.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    onTowLimitChange();
  }
});

lawLimEl.addEventListener('blur', onLawLimitChange);
lawLimEl.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    onLawLimitChange();
  }
});

document.getElementById('btnReset').addEventListener('click', function () {
  hasCalculated = false;

  ['zfw','k','taxi','rfl','block','towLimit','lawLimit'].forEach(id => {
    const el = document.getElementById(id);
    el.value = '';
    if (id === 'k' || id === 'taxi') {
      el.readOnly = false;
    }
  });

  zfwEl.className   = 'state-adjust';
  rflEl.className   = 'state-adjust';
  blockEl.className = 'state-adjust';
  kEl.className     = 'state-edit';
  taxiEl.className  = 'state-edit';

  resetLimitStyling();
  clearResults();
  limitInfoEl.textContent = '';
});

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js')
      .catch(err => console.log('SW registration failed', err));
  });
}
</script>
</body>
</html>
